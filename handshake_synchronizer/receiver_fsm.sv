// FSM for RX handshake snchronizer
module receiver_fsm(
  input   logic dest_clk, dest_reset, // posedge dest_clk and asynchronous posedge dest_reset
  input   logic req_i, // req_i = 1 generated by tx_fsm indicating to receiver_fsm new data req_iuest is available. Also indicating start of 4-phase handshake
                       // req_i = 0 generated by tx_fsm indicating to receiver_fsm that is has transmitted current data or there is no new data to be transmitted
  output  logic ack_o, // ack_o = 1 sent by receiver_fsm to tx_fsm, indicating that it is ack_onowleding the the req_iuest for new data
                       // ack_o = 0 sent by receiver_fsm to tx_fsm, indicating that receiver_fsm has received the new data. Also indicating end of 4-phase handshake.
  output  logic data_in_en // data_in_en = 1 generated by receiver_fsm to enable loading of the incoming data from tx_fsm in destination register
                           // data_in_en = 0 generated by receiver_fsm to disable loading of the incoming data from tx_fsm in destination register
);

// state encoding and state variable
enum logic{
  ACK_REQ_PHASE1  = 1'b0, // FSM state to assert ack_o = 0, data_in_en = 0 and wait for req_i = 1
  ACK_REQ_PHASE2  = 1'b1  // FSM state to assert ack_o = 1, data_in_en = 1 and wait for req_i = 0
} state;


// FSM with single always block for next state, 
// present state flipflop and output logic 
always_ff@(posedge dest_clk, posedge dest_reset) begin
 if(dest_reset) begin
      ack_o <= 0;
      data_in_en <= 0;
      state <= ACK_REQ_PHASE1;
 end
 else begin
  case(state)
     // Wait for req_iuest data coming from tx_fsm until then do not
     // enable loading of data in the data register
     ACK_REQ_PHASE1: begin
			ack_o <= 0;
			data_in_en <= 0;
			if(req_i) begin
				state <= ACK_REQ_PHASE2;
			end
			else begin
				state <= ACK_REQ_PHASE1;
			end
     end
     // In response to req_i=1 from tx_fsm, generate ack_o = 1 and enable
     // loading of data in destination register and then wait for req_i = 0
     ACK_REQ_PHASE2: begin
			ack_o <= 1;
			data_in_en <= 1;
			if(!req_i) begin
				state <= ACK_REQ_PHASE1;
			end
			else begin
				state <= ACK_REQ_PHASE2;
			end
     end
     // In Default state move to IDLE state    
     default: begin
        state <= ACK_REQ_PHASE1;
     end
  endcase
 end
end

endmodule: receiver_fsm

